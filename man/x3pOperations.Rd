% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/x3pOperations.R
\name{x3p_elemAverage}
\alias{x3p_elemAverage}
\alias{x3p_sd}
\alias{x3p_filter}
\alias{x3p_cropWS}
\alias{x3p_to_dataFrame}
\title{Transform x3p surface matrix values}
\usage{
x3p_elemAverage(x3p1, x3p2)

x3p_sd(..., na.rm = TRUE)

x3p_filter(x3p, cond, replacement = NA, ...)

x3p_cropWS(x3p, croppingThresh = 1)

x3p_to_dataFrame(x3p, preserveResolution = FALSE)
}
\arguments{
\item{x3p1}{an x3p object}

\item{x3p2}{another x3p object}

\item{...}{one or more x3p objects}

\item{na.rm}{logical. Should missing values be removed?}

\item{x3p}{an x3p object}

\item{cond}{a Boolean function whose first argument is `x`.}

\item{replacement}{value to replace each element for which cond returns FALSE}

\item{croppingThresh}{minimum number of non-NA pixels that need to be in a
row/column for it to not be cropped out of the surface matrix}

\item{preserveResolution}{a Boolean dictating whether the scan resolution is
preserved in the returned data frame. If FALSE, then the x,y data frame
columns will be integer-valued. Otherwise, the difference between
consecutive x,y values will be equal to the scan resolution.}

\item{mask_vals}{a hexidecimal color value that corresponds to indices in a
mask whose indices are to be replaced in the associated surface matrix}
}
\description{
Transform the values of a x3p surface matrix
}
\details{
`x3p_elemAverage()` calculate the element-wise average between two surface
matrices (of the same dimensions)

`x3p_sd()` Calculate the standard deviation of x3p surface values

`x3p_filter()` replace values of a surface matrix based on an element-wise
conditional function

`x3p_cropWS()` Crop rows/columns of missing values around an x3p

`x3p_to_dataFrame()` Convert an x3p object to a data frame
}
\examples{
data("K013sA1","K013sA2")

# calculates the sd for a single x3p's surface values
x3p_sd(K013sA1)

# calculates the sd for the joint surface values for two x3ps
x3p_sd(K013sA1,K013sA2)

# calculate optimal alignment between the two x3ps
K013sA2_aligned <- cmcR::comparison_allTogether(K013sA1,K013sA2,theta = -3,
                                                returnX3Ps = TRUE,numCells = c(1,1),
                                                maxMissingProp = .99)$alignedTargetCell[[1]]

averaged <- x3p_elemAverage(K013sA1,K013sA2_aligned)

# this will replace values that are larger (in magnitude) than one standard
# deviation of the input x3p's surface values with NA:
filtered1 <- x3p_filter(K013sA1,
                        cond = function(x,thresh) x < thresh,
                        thresh = x3p_sd(K013sA1))

# this will replace all surface matrix values between -1 and 1 with 0
filtered2 <- x3p_filter(K013sA1,cond = function(x) abs(x) > 1,replacement = 0)

# exaggerated cropping for the sake of an example
cropped <- x3p_cropWS(K013sA1,croppingThresh = 100)

x3pPlot(K013sA1,K013sA2_aligned,averaged,filtered1,filtered2,cropped,
        x3pNames = c("K01sA1","K013sA2 Aligned","Averaged","Filtered1","Filtered2","Cropped"))

}
